<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
<title>Times Table Trainer</title>
<link rel="stylesheet" href="style.css" />
</head>
<body>
  <div class="wrap">
    <header>
<div class="cute-bar" aria-hidden="true">
  <span class="emoji">ğŸ§¸</span>
  <span class="emoji">ğŸ“</span>
  <span class="emoji">ğŸŒˆ</span>
  <span class="emoji">ğŸ£</span>
  <span class="emoji">âœ¨</span>
</div>

      <h1>Times Table Trainer</h1>
      <select id="tableSelect" aria-label="Choose times table">
        <option value="2">Ã—2</option><option value="3">Ã—3</option><option value="4">Ã—4</option>
        <option value="5">Ã—5</option><option value="6">Ã—6</option><option value="7" selected>Ã—7</option>
        <option value="8">Ã—8</option><option value="9">Ã—9</option><option value="10">Ã—10</option>
        <option value="11">Ã—11</option><option value="12">Ã—12</option>
      </select>
      <button id="newBtn" class="primary" type="button">New round</button>
      <div class="score-badge">Score: <span id="scoreVal">0</span> âœ…</div>
    </header>

    <div id="grid" class="grid" role="group" aria-label="Times table inputs"></div>

    <div class="bar">
      <div id="msg" class="msg" aria-live="polite"></div>
      <button id="revealBtn" type="button" style="display:none">Reveal</button>
    </div>
  </div>

  <script type="module">
    import { TimesTableGame } from './game.js';

    const ROWS = 5, COLS = 2;
    const DEFAULT_TABLE = 7;
    const DEBOUNCE_MS = 500;

    const gridEl      = document.getElementById('grid');
    const msgEl       = document.getElementById('msg');
    const tableSelect = document.getElementById('tableSelect');
    const newBtn      = document.getElementById('newBtn');
    const revealBtn   = document.getElementById('revealBtn');
    const scoreValEl  = document.getElementById('scoreVal');
   
    /* ===== Emoji burst helpers ===== */
const FX_EMOJIS = ['ğŸ','ğŸŒ','ğŸ‡','ğŸ‰','ğŸ“','ğŸ¥‘','ğŸ•','ğŸª','ğŸ©','ğŸŸ','ğŸ”','ğŸ­','ğŸ§',
                   'ğŸ¶','ğŸ±','ğŸ¹','ğŸ°','ğŸ¦Š','ğŸ¼','ğŸ¸','ğŸ¦„'];
function emitEmojiBurstFromCell(cell, count = 16) {
  const fx = document.getElementById('fx');
  if (!fx || !cell) return;
  const r = cell.getBoundingClientRect();
  const x = r.left + r.width/2;
  const y = r.top  + r.height/2;
  for (let i = 0; i < count; i++) {
    const el = document.createElement('span');
    el.className = 'emoji-particle';
    el.textContent = FX_EMOJIS[Math.floor(Math.random() * FX_EMOJIS.length)];
    const angle = Math.random() * Math.PI * 2;
    const dist  = 60 + Math.random() * 70;     // px
    const dx = Math.cos(angle) * dist;
    const dy = Math.sin(angle) * dist;
    const dur = 700 + Math.random() * 500;     // 0.7â€“1.2s
    el.style.left = x + 'px';
    el.style.top  = y + 'px';
    el.style.setProperty('--dx', dx.toFixed(1) + 'px');
    el.style.setProperty('--dy', dy.toFixed(1) + 'px');
    el.style.setProperty('--dur', dur.toFixed(0) + 'ms');
    fx.appendChild(el);
    el.addEventListener('animationend', () => el.remove());
  }
}

/* ===== Confetti helpers ===== */
const CONFETTI_COLORS = ['#ff3b3b','#ff7a00','#ffd400','#2bd36b','#2ba8ff','#7a5cff','#ff5cc8','#00c2b2'];
function emitConfettiFromCell(cell, count = 28) {
  const fx = document.getElementById('fx');
  if (!fx || !cell) return;

  const rect = cell.getBoundingClientRect();
  const startX = rect.left + rect.width / 2;
  const startY = rect.top  + rect.height / 2;

  for (let i = 0; i < count; i++) {
    const el = document.createElement('i');
    // ~25% triangles, rest rectangles
    if (Math.random() < 0.25) el.className = 'confetti tri'; else el.className = 'confetti';

    // random size
    const w = 6 + Math.random() * 6;          // 6â€“12
    const h = 10 + Math.random() * 10;        // 10â€“20
    el.style.setProperty('--w', `${w}px`);
    el.style.setProperty('--h', `${h}px`);

    // color
    el.style.setProperty('--c', CONFETTI_COLORS[Math.floor(Math.random()*CONFETTI_COLORS.length)]);

    // angle and distance
    const angle = Math.random() * Math.PI * 2;
    const dist  = 70 + Math.random() * 90;    // 70â€“160 px
    const dx    = Math.cos(angle) * dist;
    const dy    = Math.sin(angle) * dist;

    // gravity pull (extra drop at the end)
    const g     = 60 + Math.random() * 90;    // 60â€“150 px

    // rotations
    const r0 = Math.floor(Math.random()*180);
    const r1 = r0 + (90 + Math.random()*180);
    const r2 = r1 + (60 + Math.random()*120);

    // durations
    const dur  = 700 + Math.random() * 500;   // 0.7â€“1.2s
    const spin = 400 + Math.random() * 600;   // 0.4â€“1.0s

    // position at start (absolute to viewport)
    el.style.left = `${startX}px`;
    el.style.top  = `${startY}px`;

    // CSS custom properties drive the keyframes
    el.style.setProperty('--x0', '0');
    el.style.setProperty('--y0', '0');
    el.style.setProperty('--x',  `${dx.toFixed(1)}`);
    el.style.setProperty('--y',  `${dy.toFixed(1)}`);
    el.style.setProperty('--g',  `${g.toFixed(1)}`);
    el.style.setProperty('--r0', `${r0}deg`);
    el.style.setProperty('--r1', `${r1}deg`);
    el.style.setProperty('--r2', `${r2}deg`);
    el.style.setProperty('--dur', `${Math.round(dur)}ms`);
    el.style.setProperty('--spin', `${Math.round(spin)}ms`);

    fx.appendChild(el);
    el.addEventListener('animationend', () => el.remove());
  }
}


    let game = new TimesTableGame(DEFAULT_TABLE, ROWS, COLS);

    // Track pending blanks for the current round (UI-level, robust)
    let pendingBlanks = 0;

    /* --- debounce helpers --- */
    const timers = new WeakMap();
    function clearTimer(inp){ const t = timers.get(inp); if (t){ clearTimeout(t); timers.delete(inp);} }
    function scheduleCheckForInput(inp){ clearTimer(inp); const id = setTimeout(()=>{ timers.delete(inp); checkOneInput(inp); }, DEBOUNCE_MS); timers.set(inp,id); }
    function clearAllDebounceTimers(){ gridEl.querySelectorAll('.blank input').forEach(clearTimer); }

    function updateScore(){ scoreValEl.textContent = String(game.getState().score); }

    function startNewRoundUI() {
      // re-render and reset pendingBlanks based on current game's blankIndexes
      const st = game.getState();
      pendingBlanks = st.blankIndexes.size;
      renderGrid();
    }

    function advanceRoundNow(){
      clearAllDebounceTimers();
      game.completeRound();      // +1 per completed level
      updateScore();
      announce('Level complete! ğŸ‰','good');
      game.newRound();           // difficulty may increase here
      startNewRoundUI();         // reset pending blanks & re-render
      announce('');
    }

    function checkOneInput(inp){
      const idx = Number(inp.dataset.index);
      if (Number.isNaN(idx)) return;

      const { correct, correctValue, justSolved } = game.check(idx, inp.value);
      const cell = inp.parentElement;
      cell.classList.remove('ok','wrong');

      if (correct) {
        cell.classList.add('ok');
        inp.value = String(correctValue);
        inp.readOnly = true; inp.tabIndex = -1;
        cell.classList.remove('blank');

        if (justSolved) {
          // Decrement pending blanks exactly once per cell
          pendingBlanks = Math.max(0, pendingBlanks - 1);
        }

        announce('Great! âœ…','good');

        // Advance immediately when the last blank is solved
        // Advance immediately when the last blank is solved
// Advance immediately when the last blank is solved
if (pendingBlanks === 0) {
  // ğŸ’¥ confetti from the solved cell
  emitConfettiFromCell(cell);

  // give the burst a moment to play, then advance level
  setTimeout(() => {
    advanceRoundNow();
  }, 900); // matches the confetti duration
}



      } else {
        if (String(inp.value).trim().length > 0) {
          cell.classList.add('wrong');
          announce('Keep trying!','bad');
        } else {
          announce('');
        }
      }
    }

    function renderGrid(){
      const { values, blankIndexes, correctMap, table } = game.getState();
      gridEl.innerHTML = '';

      for (let i = 0; i < values.length; i++) {
        const cell = document.createElement('div'); cell.className = 'cell';

        // left label â€œn Ã— table =â€
        const label = document.createElement('span');
        label.className = 'label';
        label.textContent = `${i+1} Ã— ${table} =`;
        cell.appendChild(label);

        const inp = document.createElement('input');
        inp.type = 'tel'; inp.inputMode = 'numeric'; inp.autocomplete = 'one-time-code';

        if (blankIndexes.has(i)) {
          cell.classList.add('blank');
          inp.value = ''; inp.placeholder='?'; inp.dataset.index = String(i);

          inp.addEventListener('input', ()=> scheduleCheckForInput(inp));
          inp.addEventListener('keydown', (e)=>{ if (e.key === 'Enter'){ e.preventDefault(); clearTimer(inp); checkOneInput(inp); }});
          inp.addEventListener('blur', ()=>{ clearTimer(inp); if (!inp.readOnly && inp.value.trim()!=='') checkOneInput(inp); });

          if (!gridEl.querySelector('.blank input')) {
            setTimeout(()=> inp.focus({ preventScroll:true }), 0);
          }
        } else {
          cell.classList.add('readonly');
          inp.value = String(values[i]); inp.readOnly = true; inp.tabIndex = -1;
        }

        const status = correctMap.get(i);
        if (status === true) cell.classList.add('ok');
        if (status === false) cell.classList.add('wrong');

        cell.appendChild(inp);
        gridEl.appendChild(cell);
      }
    }

    function announce(text,type){
      if (!msgEl) return;
      msgEl.textContent = text;
      msgEl.style.color = type==='good' ? 'var(--ok)' : type==='bad' ? 'var(--bad)' : '#111';
    }

    function revealAnswers(){
      const { values, blankIndexes } = game.getState();
      blankIndexes.forEach(idx=>{
        const cell = gridEl.children[idx];
        const inp = cell.querySelector('input');
        if (inp){
          clearTimer(inp);
          inp.value = values[idx];
          inp.readOnly = true; inp.tabIndex = -1;
          cell.classList.remove('blank','wrong');
          cell.classList.add('ok');
        }
      });
      announce('Shown the answers.','good');
      // No auto-advance on reveal (by design)
    }

    function on(el,evt,fn){ if (el) el.addEventListener(evt,fn); }
    on(tableSelect,'change', ()=>{
      game.setTable(Number(tableSelect.value));
      game.newRound();
      startNewRoundUI();
      announce('');
    });
    on(newBtn,'click', ()=>{
      game.newRound();
      startNewRoundUI();
      announce('');
    });
    on(revealBtn,'click', revealAnswers);

    // init
    startNewRoundUI();
    updateScore();
  </script>
<!-- FX layer for bursts -->
<div id="fx" aria-hidden="true"></div>

</body>
</html>

